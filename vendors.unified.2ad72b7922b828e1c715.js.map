{"version":3,"sources":["webpack:///./node_modules/unified/index.js","webpack:///./node_modules/unified/node_modules/is-buffer/index.js","webpack:///./node_modules/unified/node_modules/is-plain-obj/index.js"],"names":["bail","buffer","extend","plain","trough","vfile","module","exports","unified","attachers","transformers","namespace","frozen","freezeIndex","processor","data","key","value","arguments","length","assertUnfrozen","own","call","freeze","use","settings","addPlugin","apply","Error","addList","addPreset","result","plugins","add","index","plugin","entry","find","push","slice","parse","doc","Parser","file","assertParser","newable","String","stringify","node","Compiler","assertCompiler","assertNode","compile","run","runSync","complete","err","tree","assertDone","process","processSync","destination","values","options","transformer","undefined","Infinity","cb","Promise","executor","resolve","reject","pipeline","hasOwnProperty","p","ctx","next","contents","name","prototype","keys","type","asyncName","obj","constructor","isBuffer","Object","toString","getPrototypeOf"],"mappings":"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","file":"vendors.unified.2ad72b7922b828e1c715.js","sourcesContent":["'use strict'\n\nvar bail = require('bail')\nvar buffer = require('is-buffer')\nvar extend = require('extend')\nvar plain = require('is-plain-obj')\nvar trough = require('trough')\nvar vfile = require('vfile')\n\n// Expose a frozen processor.\nmodule.exports = unified().freeze()\n\nvar slice = [].slice\nvar own = {}.hasOwnProperty\n\n// Process pipeline.\nvar pipeline = trough()\n  .use(pipelineParse)\n  .use(pipelineRun)\n  .use(pipelineStringify)\n\nfunction pipelineParse(p, ctx) {\n  ctx.tree = p.parse(ctx.file)\n}\n\nfunction pipelineRun(p, ctx, next) {\n  p.run(ctx.tree, ctx.file, done)\n\n  function done(err, tree, file) {\n    if (err) {\n      next(err)\n    } else {\n      ctx.tree = tree\n      ctx.file = file\n      next()\n    }\n  }\n}\n\nfunction pipelineStringify(p, ctx) {\n  var result = p.stringify(ctx.tree, ctx.file)\n  var file = ctx.file\n\n  if (result === undefined || result === null) {\n    // Empty.\n  } else if (typeof result === 'string' || buffer(result)) {\n    file.contents = result\n  } else {\n    file.result = result\n  }\n}\n\n// Function to create the first processor.\nfunction unified() {\n  var attachers = []\n  var transformers = trough()\n  var namespace = {}\n  var frozen = false\n  var freezeIndex = -1\n\n  // Data management.\n  processor.data = data\n\n  // Lock.\n  processor.freeze = freeze\n\n  // Plugins.\n  processor.attachers = attachers\n  processor.use = use\n\n  // API.\n  processor.parse = parse\n  processor.stringify = stringify\n  processor.run = run\n  processor.runSync = runSync\n  processor.process = process\n  processor.processSync = processSync\n\n  // Expose.\n  return processor\n\n  // Create a new processor based on the processor in the current scope.\n  function processor() {\n    var destination = unified()\n    var length = attachers.length\n    var index = -1\n\n    while (++index < length) {\n      destination.use.apply(null, attachers[index])\n    }\n\n    destination.data(extend(true, {}, namespace))\n\n    return destination\n  }\n\n  // Freeze: used to signal a processor that has finished configuration.\n  //\n  // For example, take unified itself: it’s frozen.\n  // Plugins should not be added to it.\n  // Rather, it should be extended, by invoking it, before modifying it.\n  //\n  // In essence, always invoke this when exporting a processor.\n  function freeze() {\n    var values\n    var plugin\n    var options\n    var transformer\n\n    if (frozen) {\n      return processor\n    }\n\n    while (++freezeIndex < attachers.length) {\n      values = attachers[freezeIndex]\n      plugin = values[0]\n      options = values[1]\n      transformer = null\n\n      if (options === false) {\n        continue\n      }\n\n      if (options === true) {\n        values[1] = undefined\n      }\n\n      transformer = plugin.apply(processor, values.slice(1))\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer)\n      }\n    }\n\n    frozen = true\n    freezeIndex = Infinity\n\n    return processor\n  }\n\n  // Data management.\n  // Getter / setter for processor-specific informtion.\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen)\n\n        namespace[key] = value\n\n        return processor\n      }\n\n      // Get `key`.\n      return (own.call(namespace, key) && namespace[key]) || null\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', frozen)\n      namespace = key\n      return processor\n    }\n\n    // Get space.\n    return namespace\n  }\n\n  // Plugin management.\n  //\n  // Pass it:\n  // *   an attacher and options,\n  // *   a preset,\n  // *   a list of presets, attachers, and arguments (list of attachers and\n  //     options).\n  function use(value) {\n    var settings\n\n    assertUnfrozen('use', frozen)\n\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin.apply(null, arguments)\n    } else if (typeof value === 'object') {\n      if ('length' in value) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new Error('Expected usable value, not `' + value + '`')\n    }\n\n    if (settings) {\n      namespace.settings = extend(namespace.settings || {}, settings)\n    }\n\n    return processor\n\n    function addPreset(result) {\n      addList(result.plugins)\n\n      if (result.settings) {\n        settings = extend(settings || {}, result.settings)\n      }\n    }\n\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value)\n      } else if (typeof value === 'object') {\n        if ('length' in value) {\n          addPlugin.apply(null, value)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new Error('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    function addList(plugins) {\n      var length\n      var index\n\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (typeof plugins === 'object' && 'length' in plugins) {\n        length = plugins.length\n        index = -1\n\n        while (++index < length) {\n          add(plugins[index])\n        }\n      } else {\n        throw new Error('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    function addPlugin(plugin, value) {\n      var entry = find(plugin)\n\n      if (entry) {\n        if (plain(entry[1]) && plain(value)) {\n          value = extend(entry[1], value)\n        }\n\n        entry[1] = value\n      } else {\n        attachers.push(slice.call(arguments))\n      }\n    }\n  }\n\n  function find(plugin) {\n    var length = attachers.length\n    var index = -1\n    var entry\n\n    while (++index < length) {\n      entry = attachers[index]\n\n      if (entry[0] === plugin) {\n        return entry\n      }\n    }\n  }\n\n  // Parse a file (in string or vfile representation) into a unist node using\n  // the `Parser` on the processor.\n  function parse(doc) {\n    var file = vfile(doc)\n    var Parser\n\n    freeze()\n    Parser = processor.Parser\n    assertParser('parse', Parser)\n\n    if (newable(Parser, 'parse')) {\n      return new Parser(String(file), file).parse()\n    }\n\n    return Parser(String(file), file) // eslint-disable-line new-cap\n  }\n\n  // Run transforms on a unist node representation of a file (in string or\n  // vfile representation), async.\n  function run(node, file, cb) {\n    assertNode(node)\n    freeze()\n\n    if (!cb && typeof file === 'function') {\n      cb = file\n      file = null\n    }\n\n    if (!cb) {\n      return new Promise(executor)\n    }\n\n    executor(null, cb)\n\n    function executor(resolve, reject) {\n      transformers.run(node, vfile(file), done)\n\n      function done(err, tree, file) {\n        tree = tree || node\n        if (err) {\n          reject(err)\n        } else if (resolve) {\n          resolve(tree)\n        } else {\n          cb(null, tree, file)\n        }\n      }\n    }\n  }\n\n  // Run transforms on a unist node representation of a file (in string or\n  // vfile representation), sync.\n  function runSync(node, file) {\n    var complete = false\n    var result\n\n    run(node, file, done)\n\n    assertDone('runSync', 'run', complete)\n\n    return result\n\n    function done(err, tree) {\n      complete = true\n      bail(err)\n      result = tree\n    }\n  }\n\n  // Stringify a unist node representation of a file (in string or vfile\n  // representation) into a string using the `Compiler` on the processor.\n  function stringify(node, doc) {\n    var file = vfile(doc)\n    var Compiler\n\n    freeze()\n    Compiler = processor.Compiler\n    assertCompiler('stringify', Compiler)\n    assertNode(node)\n\n    if (newable(Compiler, 'compile')) {\n      return new Compiler(node, file).compile()\n    }\n\n    return Compiler(node, file) // eslint-disable-line new-cap\n  }\n\n  // Parse a file (in string or vfile representation) into a unist node using\n  // the `Parser` on the processor, then run transforms on that node, and\n  // compile the resulting node using the `Compiler` on the processor, and\n  // store that result on the vfile.\n  function process(doc, cb) {\n    freeze()\n    assertParser('process', processor.Parser)\n    assertCompiler('process', processor.Compiler)\n\n    if (!cb) {\n      return new Promise(executor)\n    }\n\n    executor(null, cb)\n\n    function executor(resolve, reject) {\n      var file = vfile(doc)\n\n      pipeline.run(processor, {file: file}, done)\n\n      function done(err) {\n        if (err) {\n          reject(err)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          cb(null, file)\n        }\n      }\n    }\n  }\n\n  // Process the given document (in string or vfile representation), sync.\n  function processSync(doc) {\n    var complete = false\n    var file\n\n    freeze()\n    assertParser('processSync', processor.Parser)\n    assertCompiler('processSync', processor.Compiler)\n    file = vfile(doc)\n\n    process(file, done)\n\n    assertDone('processSync', 'process', complete)\n\n    return file\n\n    function done(err) {\n      complete = true\n      bail(err)\n    }\n  }\n}\n\n// Check if `value` is a constructor.\nfunction newable(value, name) {\n  return (\n    typeof value === 'function' &&\n    value.prototype &&\n    // A function with keys in its prototype is probably a constructor.\n    // Classes’ prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    (keys(value.prototype) || name in value.prototype)\n  )\n}\n\n// Check if `value` is an object with keys.\nfunction keys(value) {\n  var key\n  for (key in value) {\n    return true\n  }\n\n  return false\n}\n\n// Assert a parser is available.\nfunction assertParser(name, Parser) {\n  if (typeof Parser !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Parser`')\n  }\n}\n\n// Assert a compiler is available.\nfunction assertCompiler(name, Compiler) {\n  if (typeof Compiler !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Compiler`')\n  }\n}\n\n// Assert the processor is not frozen.\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      'Cannot invoke `' +\n        name +\n        '` on a frozen processor.\\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.'\n    )\n  }\n}\n\n// Assert `node` is a unist node.\nfunction assertNode(node) {\n  if (!node || typeof node.type !== 'string') {\n    throw new Error('Expected node, got `' + node + '`')\n  }\n}\n\n// Assert that `complete` is `true`.\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","'use strict';\n\nmodule.exports = value => {\n\tif (Object.prototype.toString.call(value) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn prototype === null || prototype === Object.prototype;\n};\n"],"sourceRoot":""}